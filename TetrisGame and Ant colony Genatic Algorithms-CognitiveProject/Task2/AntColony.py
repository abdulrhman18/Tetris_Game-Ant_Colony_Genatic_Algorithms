# -*- coding: utf-8 -*-
"""Task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jx6HRJgWCA4ZdVwP-AseLG6S0hAvLFbz
"""

import numpy as np

class Travel_Sales_Prob:
    def __init__(self, num_cities, num_ants, evaporation_rate, pheromone_levels=0.1, alpha=1.0, beta=1.0, max_iterations=50):
        self.num_cities = num_cities
        self.num_ants = num_ants
        self.P = evaporation_rate  # Pheromone evaporation rate
        self.alpha = alpha  # Influence of pheromone levels
        self.beta = beta  # Influence of heuristic information (inverse of distance)
        self.max_iterations = max_iterations
        self.pheromones = np.full((num_cities, num_cities), pheromone_levels)  # Pheromone matrix
        self.best_solution = None
        self.best_solution_length = np.inf
        self.worst_solution = None
        self.worst_solution_length = -np.inf
        self.Q = 100  # Quantity of pheromones deposited

        self.distances = self.generate_distance_matrix(num_cities)  # Distance matrix between cities

    def generate_distance_matrix(self, num_cities):
        np.random.seed(42)
        distances = np.random.randint(3, 20, size=(num_cities, num_cities))
        np.fill_diagonal(distances, 0)  # No distance from a city to itself
        return distances

    def visited_cities(self):
        start_city = np.random.randint(self.num_cities)
        path = [start_city]
        visited = np.zeros(self.num_cities, dtype=bool)
        visited[start_city] = True
        while len(path) < self.num_cities:
            current_city = path[-1]
            next_city = self.select_next_city(current_city, visited)
            path.append(next_city)
            visited[next_city] = True
        path.append(start_city)  # Close the loop
        path_length = sum(self.distances[path[i], path[(i + 1) % self.num_cities]] for i in range(self.num_cities))
        return path, path_length

    def select_next_city(self, current_city, visited):
        probabilities = self.calculate_probabilities(current_city, visited)
        return np.random.choice(self.num_cities, p=probabilities)

    def calculate_probabilities(self, current_city, visited):
        probabilities = np.zeros(self.num_cities)
        row = self.pheromones[current_city]
        for i in range(self.num_cities):
            if not visited[i]:
                probabilities[i] = (row[i] ** self.alpha) * ((1.0 / self.distances[current_city][i]) ** self.beta)
        total = np.sum(probabilities)
        return probabilities / total if total > 0 else probabilities

    def calculate_delta_pheromones(self, path):
        delta_pheromones = np.zeros((self.num_cities, self.num_cities))
        for i in range(len(path) - 1):
            x, y = path[i], path[i + 1]
            delta_pheromones[x, y] += self.Q / (self.distances[x, y] + 1)  # +1 to avoid division by zero and scale deposits
        delta_pheromones[path[-1], path[0]] += self.Q / (self.distances[path[-1], path[0]] + 1)
        return delta_pheromones

    def update_pheromones_levels(self, paths):
        self.pheromones *= (1 - self.P)
        for path in paths:
            self.pheromones += self.calculate_delta_pheromones(path)

    def optimize(self):
        for iteration in range(self.max_iterations):
            paths = [self.visited_cities() for _ in range(self.num_ants)]
            for path, path_length in paths:
                if path_length < self.best_solution_length:
                    self.best_solution_length = path_length
                    self.best_solution = path
                if path_length > self.worst_solution_length:
                    self.worst_solution_length = path_length
                    self.worst_solution = path
            self.update_pheromones_levels([path for path, _ in paths])

            if (iteration + 1) % 10 == 0:
                print(f"Iteration {iteration + 1}:")
                print("Pheromone map:")
                for row in self.pheromones:
                    print(["{:.2f}".format(x) for x in row])
                    print()
                print(f"Best path : {self.best_solution} with length {self.best_solution_length}")
                print(f"Worst path : {self.worst_solution} with length {self.worst_solution_length}")
                print()


        print("Final Best path:", self.best_solution, "with length:", self.best_solution_length)
        print("Final Worst path:", self.worst_solution, "with length:", self.worst_solution_length)

# Separate execution for 10 and 20 cities
def run_simulation(num_cities):
    num_ants_list = [1, 5, 10, 20]
    for num_ants in num_ants_list:
        # distances_matrix = Travel_Sales_Prob(num_cities, 1, 0.1).distances  # Generate distances once per city count
        # print(f"Distances for {num_cities} cities:")
        # print(distances_matrix)
        print(f"\nRunning simulation for {num_cities} cities with {num_ants} ants")
        tsp = Travel_Sales_Prob(num_cities, num_ants, 0.1, max_iterations=50)
        tsp.optimize()

if __name__ == "__main__":
    print("Simulations for 10 cities:")
    run_simulation(10)

    print("\nSimulations for 20 cities:")
    run_simulation(20)